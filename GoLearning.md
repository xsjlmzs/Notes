# Go学习笔记

环境：ubuntu 20.04

## 下载&安装

官网：https://go.dev/dl/

1、移除以前的版本&安装：

```shell
rm -rf /usr/local/go && tar -C /usr/local -xzf go1.18.1.linux-amd64.tar.gz
```

2、添加环境变量（仅当前终端生效）：

```shell
export PATH=$PATH:/usr/local/go/bin
```

可选：添加在~/.bashrc （用户级别生效）或 /etc/profile （系统级别生效）文件后

3、验证安装

```shell
go version
```

## 常用命令

```shell
go env # 显示go的环境变量。
#Unix平台下默认 $GOPATH=~/go 
#工程经过 go build、go install go get 等指令后，会将产生的二进制可执行文件放在 $GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。
go list # 用于输出包的详细信息。-json：以json格式打印代码包的相关信息。
go list -f '{{.Target}}' # 输出包的安装路径
go run . # 编译并执行，不会留可执行文件
go build # 编译包及其以来，但是不安装结果
go install # 编译和安装包
go test # 执行测试 用于测试的go文件具有_test后缀
go mod init example.com/hello # 创建名字为example.com的模块
go mod tidy # 拉取缺少的模块，移除不用的模块
```

## Go语法特别之处

在 Go 中，如果一个名字以大写字母开头，那么它就是“已导出”的。任何“未导出”的名字在该包外均无法访问。

函数可以返回任意数量的返回值。

Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。

函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。

**Go 的基本类型**有：

```go
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
    // 表示一个 Unicode 码点

float32 float64

complex64 complex128
```

变量转换需要显式转换。

常量不能用 `:=` 语法声明。

Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 `{ }` 则是必须的。

for 是 Go 中的 "while"

```go
for sum , 1000 { }
```

Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。

同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 `if` 之内。

```go
if v:=1; v , lim { }
```

在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用。

Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。

**defer语句**会将函数推迟到外层函数返回之后执行。推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。

结构体指针可以使用`.`直接访问其成员，而不是`(*p).member`。

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

**Go闭包**，闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。例如：

```go
// 函数adder返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。
func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
```

成员函数要声明为指针接受者`(* T)`才可以改变结构体内部成员的值，值接受者调用方法操作对象是原始值的副本。

**接口类型** 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。

类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。

即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。

指定了零个方法的接口值被称为 *空接口：*`interface{}` 空接口可保存任何类型的值。

**类型断言** 提供了访问接口值底层具体值的方式`t := i.(T)`。若 `i` 并未保存 `T` 类型的值，该语句就会触发一个panic。类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。`t, ok := i.(T)`

**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```

**goroutine** 是由 Go 运行时管理的轻量级线程。称作**Go程**。

Go程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。

非main函数退出后，其子Go程是不会退出的

**信道channel** 是带有类型的管道，你可以通过它用信道操作符 `<-` 来发送或者接收值。默认情况下，发送和接收操作在另一端准备好之前都会阻塞。

信道可以是 *带缓冲的*。

```go
ch := make(chan int, 100)
```

仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。

发送者可通过 `close` 关闭一个信道来表示没有需要发送的值了。

循环 `for i := range c` 会不断从信道接收值，直到它被关闭。

*注意：* 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range` 循环。

**select语句** 使一个 Go 程可以等待多个通信操作。

`select` 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。当 `select` 中的其它分支都没有准备好时，`default` 分支就会执行。

**数组** 若将某个数组传入某个函数，它将接收到该数组的一份**副本**而非指针。

**切片** 切片保存了对底层数组的引用，若你将某个切片赋予另一个切片，它们会引用同一个数组。 只要切片不超出底层数组的限制，它的长度就是可变的。

`make` 只适用于映射、切片和信道且不返回指针。

打印结构体时，改进的格式 `%+v` 会为结构体的每个字段添上字段名，而另一种格式 `%#v` 将完全按照Go的语法打印值。当遇到 `string` 或 `[]byte` 值时， 可使用 `%q` 产生带引号的字符串；而格式 `%#q` 会尽可能使用反引号。 （`%q` 格式也可用于整数和符文，它会产生一个带单引号的符文常量。） `%T`，它会打印某个值的**类型**。

每个源文件都可以通过定义自己的无参数 `init` 函数来设置一些必要的状态。

**内嵌** 结构体成员可以仅字段类型构成，调用时直接使用其类型名，并可以使用内嵌类型的方法。

```go
type name = string
type Student struct {
	int # 内嵌
	name # 内嵌
}
```

`chan<-` 只写的channel；`<-chan` 只读的channel；

